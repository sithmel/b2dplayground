(function (){

//
// Utilities
//

var Point = function (x, y){
    this.x = x;
    this.y = y;
};

Point.prototype.rotate = function (angle){
    this.x = this.x*Math.cos(angle) - this.y * Math.sin(angle);
    this.y = this.x*Math.sin(angle) + this.y * Math.cos(angle);
    return this;
};

Point.prototype.translate = function (x, y){
    this.x = this.x + x;
    this.y = this.y + y;
    return this;
};

Point.prototype.distanceFrom = function (x, y){
    var dx = this.x - x, 
        dy = this.y - y;
    return Math.sqrt(dx*dx + dy*dy);
};

var fixDef = new Box2D.Dynamics.b2FixtureDef;
fixDef.density = 1.0;
fixDef.friction = 0.5;
fixDef.restitution = 0.6;

var getDefaultFixture = function (){
    // cached fixture 
    return fixDef;
};

//
// setting global namespace
//

var PG = window.B2DPLAYGROUND;

// validators
var isAnything = occamsrazor.validator(function (obj){
    return true;
});

/*
*
* CIRCLE
*
*/

var isCircle = occamsrazor.validator(isAnything, function (obj){
    return obj.get('shape') === 'circle';
});

PG.shapes.add(function (){
    return {
        shape:      'circle',
        radius:     1,
        color:      '#22EE33',
        center_x:   null,
        center_y:   null,
        is_static:   false,
        start_x:    3,
        start_y:    3,
        start_angle:0
    };

});

//
// editor
//


PG.editor.add(function (element){
    var CircleModelView = Backbone.View.extend({
        source: '<h4>{{shape}}</h4>'+
        '<label>Radius:' + 
        '<input name="radius" data-type="float" class="radius" type="range" min="0.1" max="4" step="0.1" value="{{radius}}"/>' +
        '</label>'+
        '<label>Color:' + 
        '<input name="color" data-type="string" class="color" value="{{color}}"/>' + 
        '</label>'+
        '<label>Static:' + 
        '<select name="is_static" data-type="boolean" class="is_static">'+
        '<option {{#if is_static}}selected="selected"{{/if}} value="true">Yes</option>'+
        '<option {{#unless is_static}}selected="selected"{{/unless}} value="false">No</option>'+
        '</select>' +
        '</label>'+
        '<label>X:' + 
        '<input name="start_x" data-type="float" class="start_x" type="range" min="1" max="30" step="1" value="{{start_x}}"/>' + 
        '</label>'+
        '<label>Y:<input name="start_y" data-type="float" class="start_y" type="range" min="1" max="30" step="1" value="{{start_y}}"/>' + 
        '</label>'+
        '<input type="button" class="delete" value="delete"/>',
        events: {
            "click .delete":    "del",
            "change": "edit"
        },
        initialize: function (){
            this.template = Handlebars.compile(this.source);
        },
        render: function(){
            var html = this.template(this.model.toJSON());
            this.$el.append(html);
            return this;
        },
        del: function (){
            this.model.destroy();
        },
        edit: function (){
            var name,
                obj = PG.form2obj(this.$el);
            for (name in obj){
                this.model.set(name, obj[name]);
            }

            this.model.save();
        }
    });

    return {
        getView : function ($node){
            return new CircleModelView({model:element, el: $node });
        }
    };
}, isCircle);


PG.drawer.add(function (element){
    var GenericModelView = Backbone.View.extend({
        render: function(canvasLayer){
            var m = this.model,
                scale = canvasLayer.scale;

            canvasLayer.ctx.fillStyle = m.get('color');
            canvasLayer.ctx.beginPath();
            canvasLayer.ctx.arc(0, 0, m.get('radius') * scale, 0, Math.PI * 2, true);
            canvasLayer.ctx.closePath();
            canvasLayer.ctx.fill();

            return this;
        },
        isAt: function (x, y, canvasLayer){
            var pos = new Point(x, y),
                m = this.model,
                scale = canvasLayer.scale,
//                angle = element.get('start_angle'),
                x = element.get('start_x') * scale,
                y = element.get('start_y') * scale,
                radius = element.get('radius') * scale;

//            pos.rotate(-angle);
            pos.translate(-x, -y);

            if (pos.distanceFrom(0, 0) <= radius){
                return true;
            }
            return false;
        }
    });
    return new GenericModelView({model:element });

}, isCircle);

PG.physicEngine.add(function (element){
    return {
        add: function (world){
            var body,
                fixDef = getDefaultFixture();
                bodyDef = new Box2D.Dynamics.b2BodyDef;
                
            if (element.get('is_static') == true) {
                bodyDef.type = Box2D.Dynamics.b2Body.b2_staticBody;
            } else {
                bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
            }
            bodyDef.position.x = element.get('start_x');
            bodyDef.position.y = element.get('start_y');
            bodyDef.userData = element.id;
            bodyDef.angle = element.get('start_angle');

            body = world.CreateBody(bodyDef);

            fixDef.shape = new Box2D.Collision.Shapes.b2CircleShape(element.get('radius'));
            body.CreateFixture(fixDef);
        }
    }

}, isCircle);

/*
*
* BOX
*
*/

var isBox = occamsrazor.validator(isAnything, function (obj){
    return obj.get('shape') === 'box';
});

PG.shapes.add(function (){
    return {
            shape:      'box',
            height:     2,
            width:      1,
            color:      '#22EE33',
            center_x:   null,
            center_y:   null,
            is_static:   false,
            start_x:    3,
            start_y:    3,
            start_angle:0
    };
});



PG.editor.add(function (element){
    var BoxModelView = Backbone.View.extend({
        source: '<h4>{{shape}}</h4>'+
        '<label>Height:' + 
        '<input name="height" data-type="float" class="height" type="range" min="1" max="10" step="1" value="{{height}}"/>' + 
        '</label>'+
        '<label>Width:' + 
        '<input name="width" data-type="float" class="width" type="range" min="1" max="10" step="1" value="{{width}}"/>' + 
        '</label>'+
        '<label>Angle:' + 
        '<input name="start_angle" data-type="float" type="range" min="0" max="6.3" step="0.1" class="start_angle" value="{{start_angle}}"/>' + 
        '</label>'+
        '<label>Color:' + 
        '<input name="color" data-type="string" class="color" value="{{color}}"/>' + 
        '</label>'+
        '<label>Static:' + 
        '<select name="is_static" data-type="boolean" class="is_static">'+
        '<option {{#if is_static}}selected="selected"{{/if}} value="true">Yes</option>'+
        '<option {{#unless is_static}}selected="selected"{{/unless}} value="false">No</option>'+
        '</select>' + 
        '</label>'+
        '<label>X:' + 
        '<input name="start_x" data-type="float" class="start_x" type="range" min="1" max="30" step="1" value="{{start_x}}"/>' + 
        '</label>'+
        '<label>Y:' + 
        '<input name="start_y" data-type="float" class="start_y" type="range" min="1" max="30" step="1" value="{{start_y}}"/>' + 
        '</label>'+
        '<input type="button" class="delete" value="delete"/>',
        events: {
            "click .delete":    "del",
            "change": "edit"
        },
        initialize: function (){
            this.template = Handlebars.compile(this.source);
        },
        render: function(){
            var html = this.template(this.model.toJSON());
            this.$el.append(html);
            return this;
        },
        del: function (){
            this.model.destroy();
        },
        edit: function (){
            var name,
                obj = PG.form2obj(this.$el);
            for (name in obj){
                this.model.set(name, obj[name]);
            }

            this.model.save();
        }
    });

    return {
        getView : function ($node){
            return new BoxModelView({model:element, el: $node });
        }
    };
}, isBox);

// draw on the canvas

PG.drawer.add(function (element){
    var GenericModelView = Backbone.View.extend({
        render: function(canvasLayer){
            var m = this.model,
                scale = canvasLayer.scale,
//                pos = m.get('pos'),
                w = m.get('width') * scale,
                h = m.get('height') * scale;

            canvasLayer.ctx.fillStyle = m.get('color');
            canvasLayer.ctx.fillRect(
                -(w / 2),
                -(h / 2),
                w,
                h
            );
            return this;
        },
        isAt: function (x, y, canvasLayer){
            var pos = new Point(x, y),
                m = this.model,
                scale = canvasLayer.scale;
                angle = element.get('start_angle'),
                x = element.get('start_x') * scale,
                y = element.get('start_y') * scale,
                w = element.get('width') * scale,
                h = element.get('height') * scale;

            pos.translate(-x, -y);
           // pos.rotate(-angle);
// test
            var pt1 = new Point(-w/2, -h/2).translate(x, y);
            var pt2 = new Point(w/2, h/2).translate(x, y);
            canvasLayer.ctx.save();
canvasLayer.ctx.beginPath();
canvasLayer.ctx.moveTo(pt1.x,pt1.y);
canvasLayer.ctx.lineTo(pt2.x,pt2.y);
canvasLayer.ctx.strokeStyle = 'red';
canvasLayer.ctx.stroke();
            canvasLayer.ctx.restore();


// test -end



            if (pos.x > -(w/2) && pos.x < w/2 && pos.y > -(h/2) && pos.y < h/2){
                return true;
            }
            return false;
        }
    });
    return new GenericModelView({model:element });

}, isBox);


/*add to world*/


PG.physicEngine.add(function (element){
    return {
        add: function (world){
            var body,
                fixDef = getDefaultFixture();
                bodyDef = new Box2D.Dynamics.b2BodyDef;
                
            if (element.get('is_static') == true) {
                bodyDef.type = Box2D.Dynamics.b2Body.b2_staticBody;
            } else {
                bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
            }
            bodyDef.position.x = element.get('start_x');
            bodyDef.position.y = element.get('start_y');
            bodyDef.userData = element.id;
            bodyDef.angle = element.get('start_angle');

            body = world.CreateBody(bodyDef);

            fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape();
            fixDef.shape.SetAsBox(element.get('width') / 2, element.get('height') / 2);

            body.CreateFixture(fixDef);
        }
    }
}, isBox);

//PG.collection.fetch();
PG.start();
}());


